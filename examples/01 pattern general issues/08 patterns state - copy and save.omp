; OM File Header - Saved 2024/01/02 16:49:14
; (7.04 :patc (om-make-point 334 10) (om-make-point 0 0) (om-make-point 1283 711) "" 183 0 "2024/01/02 16:42:20" "2024/01/02 16:49:02")
; End File Header
(in-package :om)(load-lib-for (quote ("Patterns")))(setf *om-current-persistent* (om-load-patch1 "08 patterns state - copy and save" (quote ((let ((box (om-load-boxcomment "comment 2" (om-make-point 165 59) (quote "<- Try duplicating this (Ctrl-drag) after locking") nil (om-make-point 315 266) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 254 153) (quote "any pattern class can be locked to save its internal state$$a locked pattern can be copied, and the copy will maintain the same internal state as the original$$This can be useful when comparing several versions of the same patch") nil (om-make-point 377 67) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "BPF" (quote bpf) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "X coordinates (list)" "x-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "Y coordinates (list)" "y-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "precision (integer) [0 - 10]" "decimals" 0))) (om-make-point 492 486) (om-make-point 235 89) (let ((newobj (when (find-class (quote bpf) nil) (let ((newbpf (simple-bpf-from-list (quote (33 35 38 38 40 47 50 51 58 58 65 66 72 73 78 88 91 101 102 103 106 106 113 114)) (quote (500 1500 1000 1600 100 400 1100 2100 0 700 1300 600 1800 300 1700 1200 200 2300 900 800 1900 2000 2200 1400)) (quote bpf) 0))) (setf (bpfcolor newbpf) (om-make-color 0 0 0)) (set-name newbpf "BPF") newbpf)))) (when newobj) newobj) nil nil (pairlis (quote (picture winpos winsize)) (list nil (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil (quote nil)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 617 341) (om-make-point 32 30) 24 "24" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-NEXT" (quote p-next) (quote ((om-load-inputfun (quote input-funbox) "pattern" "OBJ" (quote n)) (om-load-inputfun (quote input-funbox) "pattern" "NUM" 24))) (om-make-point 557 382) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-MARKOV-ANALYZE 2" (quote p-markov-analyze) (quote ((om-load-inputfun (quote input-funbox) "" "SEQ" nil) (om-load-inputkeyword (quote input-keyword) "" "order" (quote :order) nil nil))) (om-make-point 512 266) nil (list (let ((patterns::obj (clos::mlf-allocate-instance (quote patterns::markov)))) (clos::mlf-set-instance-slots patterns::obj (quote ((patterns::name) (patterns::flags . 32793) (patterns::data ((30 94) 1.0 (74 1.0 1.0)) ((31 68) 1.0 (108 1.0 1.0)) ((35 72) 1.0 (31 1.0 1.0)) ((36 96) 1.0 (98 1.0 1.0)) ((37 30) 1.0 (94 1.0 1.0)) ((41 51) 1.0 (37 1.0 1.0)) ((42 77) 1.0 (43 1.0 1.0)) ((43 41) 1.0 (51 1.0 1.0)) ((48 85) 1.0 (107 1.0 1.0)) ((48 89) 1.0 (98 1.0 1.0)) ((51 37) 1.0 (30 1.0 1.0)) ((53 59) 1.0 (100 1.0 1.0)) ((55 48) 1.0 (89 1.0 1.0)) ((58 42) 1.0 (77 1.0 1.0)) ((59 100) 1.0 (65 1.0 1.0)) ((65 85) 1.0 (66 1.0 1.0)) ((66 71) 1.0 (90 1.0 1.0)) ((68 108) 1.0 (91 1.0 1.0)) ((71 90) 1.0 (55 1.0 1.0)) ((72 31) 1.0 (68 1.0 1.0)) ((74 48) 1.0 (85 1.0 1.0)) ((77 43) 1.0 (41 1.0 1.0)) ((85 66) 1.0 (71 1.0 1.0)) ((85 107) 1.0 (107 1.0 1.0)) ((89 98) 1.0 (36 1.0 1.0)) ((90 55) 1.0 (48 1.0 1.0)) ((91 101) 1.0 (58 1.0 1.0)) ((94 74) 1.0 (48 1.0 1.0)) ((96 98) 1.0 (35 1.0 1.0)) ((98 35) 1.0 (72 1.0 1.0)) ((98 36) 1.0 (96 1.0 1.0)) ((100 65) 1.0 (85 1.0 1.0)) ((101 58) 1.0 (42 1.0 1.0)) ((107 53) 1.0 (59 1.0 1.0)) ((107 107) 1.0 (53 1.0 1.0)) ((108 91) 1.0 (101 1.0 1.0))) (length . 36) (patterns::datum . :not-a-datum) (patterns::period . #S(patterns::period :count 12 :length 36 :stream nil :default 36 :omit 0 :reps 14 :hook nil)) (patterns::value . 68) (patterns::state) (patterns::repeat . 1152921504606846975) (patterns::parser) (patterns::hooks) (patterns::returning) (patterns::counting . :periods) (patterns::traversing . :depth-first) (patterns::past 31 68) (patterns::order . 2) (patterns::produce)))) patterns::obj)) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "BPF" (quote bpf) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "X coordinates (list)" "x-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "Y coordinates (list)" "y-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "precision (integer) [0 - 10]" "decimals" 0))) (om-make-point 208 482) (om-make-point 235 89) (let ((newobj (when (find-class (quote bpf) nil) (let ((newbpf (simple-bpf-from-list (quote (0 100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300)) (quote (109 75 66 42 51 60 61 36 41 116 87 54 103 43 89 118 103 117 73 105 111 55 38 56)) (quote bpf) 0))) (setf (bpfcolor newbpf) (om-make-color 0 0 0)) (set-name newbpf "BPF") newbpf)))) (when newobj) newobj) nil nil (pairlis (quote (picture winpos winsize)) (list nil (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil (quote nil)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 294 333) (om-make-point 32 30) 24 "24" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-NEXT" (quote p-next) (quote ((om-load-inputfun (quote input-funbox) "pattern" "OBJ" (quote n)) (om-load-inputfun (quote input-funbox) "pattern" "NUM" 24))) (om-make-point 234 374) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 299 217) (om-make-point 26 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 214 180) (om-make-point 80 60) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 289 139) (om-make-point 32 30) 36 "36" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-RANDOM" (quote om-random) (quote ((om-load-inputfun (quote input-funbox) "min" "LOW" 0) (om-load-inputfun (quote input-funbox) "max" "HIGH" 1))) (om-make-point 207 109) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 209 69) (om-make-point 32 30) 30 "30" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 249 69) (om-make-point 38 30) 120 "120" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-MARKOV-ANALYZE 2" (quote p-markov-analyze) (quote ((om-load-inputfun (quote input-funbox) "" "SEQ" nil) (om-load-inputkeyword (quote input-keyword) "" "order" (quote :order) nil nil))) (om-make-point 218 257) nil (list (let ((patterns::obj (clos::mlf-allocate-instance (quote patterns::markov)))) (clos::mlf-set-instance-slots patterns::obj (quote ((patterns::name) (patterns::flags . 32793) (patterns::data ((31 34) 1.0 (109 1.0 1.0)) ((34 109) 1.0 (75 1.0 1.0)) ((36 41) 1.0 (116 1.0 1.0)) ((38 56) 1.0 (47 1.0 1.0)) ((41 116) 1.0 (87 1.0 1.0)) ((42 51) 1.0 (60 1.0 1.0)) ((43 89) 1.0 (118 1.0 1.0)) ((47 86) 1.0 (70 1.0 1.0)) ((50 65) 1.0 (31 1.0 1.0)) ((51 60) 1.0 (61 1.0 1.0)) ((53 112) 1.0 (50 1.0 1.0)) ((54 103) 1.0 (43 1.0 1.0)) ((55 38) 1.0 (56 1.0 1.0)) ((55 115) 1.0 (115 1.0 1.0)) ((56 47) 1.0 (86 1.0 1.0)) ((60 61) 1.0 (36 1.0 1.0)) ((61 36) 1.0 (41 1.0 1.0)) ((65 31) 1.0 (34 1.0 1.0)) ((66 42) 1.0 (51 1.0 1.0)) ((70 55) 1.0 (115 1.0 1.0)) ((73 105) 1.0 (111 1.0 1.0)) ((75 66) 1.0 (42 1.0 1.0)) ((86 70) 1.0 (55 1.0 1.0)) ((87 54) 1.0 (103 1.0 1.0)) ((89 118) 1.0 (103 1.0 1.0)) ((103 43) 1.0 (89 1.0 1.0)) ((103 117) 1.0 (73 1.0 1.0)) ((105 111) 1.0 (55 1.0 1.0)) ((109 75) 1.0 (66 1.0 1.0)) ((111 55) 1.0 (38 1.0 1.0)) ((112 50) 1.0 (65 1.0 1.0)) ((115 53) 1.0 (112 1.0 1.0)) ((115 115) 1.0 (53 1.0 1.0)) ((116 87) 1.0 (54 1.0 1.0)) ((117 73) 1.0 (105 1.0 1.0)) ((118 103) 1.0 (117 1.0 1.0))) (length . 36) (patterns::datum . :not-a-datum) (patterns::period . #S(patterns::period :count 12 :length 36 :stream nil :default 36 :omit 0 :reps 0 :hook nil)) (patterns::value . 56) (patterns::state) (patterns::repeat . 1152921504606846975) (patterns::parser) (patterns::hooks) (patterns::returning) (patterns::counting . :periods) (patterns::traversing . :depth-first) (patterns::past 38 56) (patterns::order . 2) (patterns::produce)))) patterns::obj)) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 2 2 nil 0) (5 0 4 0 nil 0) (3 0 4 1 nil 0) (8 0 6 2 nil 0) (15 0 8 0 nil 0) (7 0 8 1 nil 0) (12 0 10 0 nil 0) (11 0 10 1 nil 0) (13 0 12 0 nil 0) (14 0 12 1 nil 0) (10 0 15 0 nil 0) (9 0 15 1 nil 0))) nil 7.04))
