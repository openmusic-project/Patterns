; OM File Header - Saved 2017/04/04 11:48:14
; (6.120001 :patc (om-make-point 10 160) (om-make-point 0 0) (om-make-point 1099 820) "" 183 0 "2017/04/04 9:38:14" "2017/04/04 11:07:12")
; End File Header
(in-package :om)(load-lib-for (quote ("Patterns")))(setf *om-current-persistent* (om-load-patch1 "2 a - range" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 207 45) (quote "generate notes based on pattern,$stop after \":repeat\" periods") nil (om-make-point 706 362) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 676 407) (om-make-point 41 32) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" (quote n)) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 100))) (om-make-point 654 442) (om-make-point 29 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 70)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 541 540) (om-make-point 446 127) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (5900) (5800) (5700) (5600) (5500) (5400) (5300) (5200) (5100) (5000) (4900) (4800) (7700) (7500) (7300) (7100) (6900) (6700) (6500) (6300) (6100) (5900) (5700) (5500) (5300) (5100) (4900) (6000) (5700) (5400) (5100) (4800) (7700) (7600) (7500) (7400) (7300) (7200) (7100) (7000) (6900) (6800) (6700) (6600) (6500) (6400) (6300) (6200) (6100) (6000) (5900) (5800) (5700) (5600) (5500) (5400) (5300) (5200) (5100) (5000) (4900) (4800) (6000) (5800) (5600) (5400) (5200) (5000) (4800) (7700) (7400) (7100) (6800) (6500) (6200) (5900) (5600) (5300) (5000))) :lonset (quote (0 70 140 210 280 350 420 490 560 630 700 770 840 910 980 1050 1120 1190 1260 1330 1400 1470 1540 1610 1680 1750 1820 1890 1960 2030 2100 2170 2240 2310 2380 2450 2520 2590 2660 2730 2800 2870 2940 3010 3080 3150 3220 3290 3360 3430 3500 3570 3640 3710 3780 3850 3920 3990 4060 4130 4200 4270 4340 4410 4480 4550 4620 4690 4760 4830 4900 4970 5040 5110 5180 5250 5320 5390 5460 5530 6530)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 0 0) (om-make-point 555 434) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gf) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "play-pat" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil))) (om-make-point 641 348) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 263 489) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 202 404) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-EOD?" (quote p-eod?) (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 42 228) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-NEXT" (quote p-next) (quote ((om-load-inputfun (quote input-funbox) "pattern" "OBJ" nil))) (om-make-point 161 228) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOT" (quote not) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 50 338) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "while" (quote whileloop) (quote ((om-load-inputfun (quote input-funbox) "condition" "EXPR" nil))) (om-make-point 31 403) nil nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 103 68) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 264 594) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 164 594) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 1 0 0 nil 0) (3 0 1 0 nil 0) (6 0 2 0 nil 0) (6 0 3 0 nil 0) (2 0 4 0 nil 0) (4 0 5 0 nil 0) (0 0 7 0 nil 0) (1 0 8 0 nil 0))) 1 "play-pat" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 56 30) (quote ":repeat") nil (om-make-point 810 230) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 34 30) (quote ":by") nil (om-make-point 750 230) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 61 30) (quote ":downto") nil (om-make-point 690 230) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 45 30) (quote ":from") nil (om-make-point 650 231) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 824 199) (om-make-point 27 32) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 769 101) (om-make-point 55 32) (list 1 2 3) "(1 2 3)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-CYCLE" (quote p-cycle) (quote ((om-load-inputfun (quote input-funbox) "data" "OF" nil))) (om-make-point 773 139) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-RANGE 2" (quote p-range) (quote ((om-load-inputkeyword (quote input-keyword) "" "from" (quote :from) 0 (list (list "from" 0) (list "initially" 0))) (om-load-inputkeyword (quote input-keyword) "" "downto" (quote :downto) nil (list (list "inclusive" (quote t)) (list "exclusive" nil))) (om-load-inputkeyword (quote input-keyword) "" "by" (quote :by) nil nil) (om-load-inputkeyword (quote input-keyword) "" "repeat" (quote :repeat) nil nil))) (om-make-point 640 255) (om-make-point 235 74) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 53 31) (quote ":below") nil (om-make-point 473 129) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-RANGE" (quote p-range) (quote ((om-load-inputkeyword (quote input-keyword) "" "below" (quote :below) 1 nil))) (om-make-point 512 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 719 165) (om-make-point 34 32) 48 "48" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 661 101) (om-make-point 59 32) (list 60 77) "(60 77)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-CYCLE" (quote p-cycle) (quote ((om-load-inputfun (quote input-funbox) "data" "OF" nil))) (om-make-point 667 145) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 544 211) (om-make-point 34 32) 20 "20" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-NEXT" (quote p-next) (quote ((om-load-inputfun (quote input-funbox) "pattern" "OBJ" (quote n)) (om-load-inputfun (quote input-funbox) "pattern" "NUM" (quote t)))) (om-make-point 522 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 522 103) (om-make-point 34 32) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 389 705) (quote "Generates numbers from an iterative description.$$range supports the following slot initializations:$$:from {number | pattern}$    The starting value to return from the range. The starting$    value is reset each time it exceeds range boundaries or, if$    the range is unbounded, once each period of the pattern. The$    default value is 0.$$:initially {number}$    Sets the starting value for the iteration one time and then$    never resets it. Only appropriate if the range has no upper$    or lower boundary.$$:to {number | pattern}$    An optional inclusive upper bound on the range. If this value$    is exceeded then the range is reset to its starting value.$$:below {number | pattern}$    Like :to except that the upper bound is exclusive.$$:downto {number | pattern}$    An optional inclusive lower bound on the range. If this value$    is exceeded then the range is reset to its starting value.$$:above {number | pattern}$    Like :downto except that the lower bound is exclusive.$$:by {number | pattern}$    The increment to step between numbers in the range. If the$    value is a pattern a new increment will be reselected$    whenever the starting value is reset.$$:stepping {pattern}$    Like :by except that a increment is reselected from pattern$    each time.$$For bounded ranges the default period length is the number of$values generated in the bounded iteration. For unbounded ranges$the default period length is 1. Note that a range may contain$both upper and lower boundaries. Combining these with a$random :stepping pattern implements bounded random walks.$$See generic pattern initializations for documentation on$additional keyword initializations to the pattern.") "" (om-make-point 44 75) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 190 38) (quote "range") "" (om-make-point 44 36) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 15.998697916666666D0 :family "Liberation Sans" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 2 0 nil 0) (1 0 2 1 nil 0) (2 0 3 1 nil 0) (12 0 4 0 nil 0) (10 0 11 0 nil 0) (17 0 12 0 nil 0) (15 0 12 1 nil 0) (11 0 12 2 nil 0) (9 0 12 3 nil 0) (20 0 14 0 nil 0) (16 0 17 0 nil 0) (14 0 19 0 nil 0) (18 0 19 1 nil 0))) nil 6.120001))
