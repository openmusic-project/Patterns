; OM File Header - Saved 2017/04/04 11:48:14
; (6.120001 :patc (om-make-point 10 160) (om-make-point 50 50) (om-make-point 1020 707) "" 183 0 "2017/04/04 11:47:24" "2017/04/04 11:47:24")
; End File Header
(in-package :om)(load-lib-for (quote ("Patterns")))(setf *om-current-persistent* (om-load-patch1 "3 a - join" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 162 60) (quote "Generating random notes$with consistent rhythmic$identities. ") nil (om-make-point 741 343) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 11" (quote t) (quote nil) (om-make-point 887 523) (om-make-point 41 32) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 673 495) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 465 560) (om-make-point 491 94) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7900) (7200) (7200) (7700) (7700) (7400) (7800) (7400) (7400) (7300) (7200) (7700) (7300) (7700) (7400) (7200) (7700) (7400) (7400) (7700) (7200) (7300) (7700) (7200) (7700) (7700) (7900) (7400) (7700) (7400) (7400) (7900) (7300) (7300) (7900) (7700) (7700) (7500) (7200) (7800) (7400) (7700) (7700) (7400) (7400) (7300) (7200) (7900) (7400) (7800) (7400) (7200) (7300) (7300) (7700) (7200) (7800) (7500) (7400) (7500))) :lonset (quote (0 200 400 600 700 800 900 950 1050 1150 1200 1400 1500 1550 1650 1750 1950 2050 2150 2250 2350 2550 2600 2700 2900 3000 3100 3300 3400 3500 3600 3700 3900 3950 4000 4200 4300 4400 4450 4650 4700 4800 4900 5000 5100 5200 5250 5450 5650 5750 5800 5900 6100 6150 6200 6300 6500 6550 6600 6700 6750)) :ldur (quote ((200) (200) (200) (100) (100) (100) (50) (100) (100) (50) (200) (100) (50) (100) (100) (200) (100) (100) (100) (100) (200) (50) (100) (200) (100) (100) (200) (100) (100) (100) (100) (200) (50) (50) (200) (100) (100) (50) (200) (50) (100) (100) (100) (100) (100) (50) (200) (200) (100) (50) (100) (200) (50) (50) (100) (200) (50) (50) (100) (50))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 100)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "N->MC" (quote n->mc) (quote ((om-load-inputfun (quote input-funbox) "note name or list of note names" "STRS" (list "C3")))) (om-make-point 613 493) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 675 443) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 622 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 650 373) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 502 478) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-NEXT" (quote p-next) (quote ((om-load-inputfun (quote input-funbox) "pattern" "OBJ" nil))) (om-make-point 502 403) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 10" (quote t) (quote nil) (om-make-point 549 436) (om-make-point 34 32) 60 "60" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-WEIGHTING 4" (quote p-weighting) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil))) (om-make-point 488 331) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 4" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote a)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote b)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote c)))) (om-make-point 570 274) (om-make-point 192 44) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-JOIN 3" (quote p-join) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil))) (om-make-point 808 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-JOIN 2" (quote p-join) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil))) (om-make-point 648 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 849 80) (om-make-point 34 32) 50 "50" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 704 27) (om-make-point 116 32) (list "c#4" "d#4" "f#4") "(\"c#4\" \"d#4\" \"f#4\")" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 830 26) (om-make-point 27 32) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-WEIGHTING 3" (quote p-weighting) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil) (om-load-inputkeyword (quote input-keyword) "" "for" (quote :for) nil nil))) (om-make-point 765 70) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote a)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote b)))) (om-make-point 817 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 574 26) (om-make-point 71 32) (list "d4" "f4") "(\"d4\" \"f4\")" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 660 26) (om-make-point 27 32) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-WEIGHTING 2" (quote p-weighting) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil) (om-load-inputkeyword (quote input-keyword) "" "for" (quote :for) nil nil))) (om-make-point 605 70) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 689 80) (om-make-point 41 32) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote a)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote b)))) (om-make-point 657 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 424 26) (om-make-point 74 32) (list "c4" "g4") "(\"c4\" \"g4\")" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 510 26) (om-make-point 27 32) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 539 80) (om-make-point 41 32) 200 "200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote a)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" (quote b)))) (om-make-point 507 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-WEIGHTING" (quote p-weighting) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil) (om-load-inputkeyword (quote input-keyword) "" "for" (quote :for) nil nil))) (om-make-point 455 70) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-JOIN" (quote p-join) (quote ((om-load-inputfun (quote input-funbox) "" "OF" nil))) (om-make-point 498 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 378 525) (quote "Defines a merging of two or more sub-patterns. The joined$patterns are read in parallel and their elements are returned as$list elements with the same ordering as the sub-patterns in the$join.$$join supports the following slot initializations:$$:format list$$    Specifies the method for merging data from the individual$    patterns. If the initialization is not specified then each$    sub-pattern will be read each time the join is read and the$    join pattern will be at end-of-period when the all of the$    sub-patterns are concurrently at end-of-period. Otherwise$    list is of the format$$        ({:eop | true | false}+)$$    where there are as many elements in list as their are joined$    patterns and each entry in the list determines how its$    corresponding sub-pattern (in left-to-right-order in the$    pattern data) is treated by the join. The value :eop means$    that the corresponding pattern is read each time the join is$    read and it determines when the join is at end-of-period. If$    the value is true then the corresponding pattern is read each$    time the join is read but it does not contribute to the$    period length of the join. If the value is false then the$    corresponding pattern is read only once per period of the$    join. A false entry will therefore \"spread\" one element from$    the corresponding sub-pattern over all the other joined$    elements returned in the period.$$See generic pattern initializations for documentation on$additional keyword initializations to the pattern.") nil (om-make-point 32 63) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 12 :family "Liberation Sans" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 355 38) (quote "join - random notes with consistent rhythm") "" (om-make-point 34 36) nil (om-make-color 0 0 0) (om-make-font "Liberation Sans" 15.998697916666666D0 :family "Liberation Sans" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 2 1 nil 0) (4 0 3 1 nil 0) (2 0 3 2 nil 0) (1 0 3 7 nil 0) (6 0 4 0 nil 0) (7 0 5 0 nil 0) (7 0 6 0 nil 0) (8 0 7 0 nil 0) (9 0 8 0 nil 0) (10 0 8 1 nil 0) (11 0 9 0 nil 0) (12 0 11 0 nil 0) (30 0 12 0 nil 0) (14 0 12 1 nil 0) (13 0 12 2 nil 0) (19 0 13 0 nil 0) (24 0 14 0 nil 0) (16 0 18 0 nil 0) (17 0 18 1 nil 0) (18 0 19 0 nil 0) (15 0 19 1 nil 0) (20 0 22 0 nil 0) (21 0 22 1 nil 0) (22 0 24 0 nil 0) (23 0 24 1 nil 0) (29 0 28 0 nil 0) (27 0 28 1 nil 0) (25 0 29 0 nil 0) (26 0 29 1 nil 0) (28 0 30 0 nil 0))) nil 6.120001))
